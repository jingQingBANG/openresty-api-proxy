worker_processes auto;
error_log logs/error.log warn;
pid logs/nginx.pid;

# 优化系统资源
worker_rlimit_nofile 65535;

events {
    worker_connections 10240;
    use epoll;
    multi_accept on;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Lua 库路径 (包含 prometheus 库路径)
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/site/lualib/?.lua;;";
    lua_package_cpath "/usr/local/openresty/nginx/lua/?.so;/usr/local/openresty/lualib/?.so;;";
    
    # 1. 共享字典 (用于 Lua 全局变量共享)
    # 限流用
    lua_shared_dict limit_req_store 10m; 
    # Prometheus 指标存储 (lua-resty-prometheus)
    lua_shared_dict metrics_store 32m; 
    # 熔断器用 (服务健康状态)
    lua_shared_dict health_check 5m;
    # Prometheus 指标锁
    lua_shared_dict prometheus_locks 128k; 
    
    # 2. 结构化日志格式 (JSON)
    log_format json_log escape=json '{'
        '"@timestamp":"$time_iso8601",'
        '"request_id":"$http_x_onekey_request_id",'
        '"remote_addr":"$remote_addr",'
        '"host":"$host",'
        '"uri":"$uri",'
        '"args":"$args",'
        '"method":"$request_method",'
        '"status":$status,'
        '"body_bytes_sent":$body_bytes_sent,'
        '"request_time":$request_time,'
        '"upstream_addr":"$upstream_addr",'
        '"upstream_response_time":"$upstream_response_time",'
        '"http_referrer":"$http_referer",'
        '"http_user_agent":"$http_user_agent",'
        '"provider":"$sent_http_x_api_provider",'
        '"trace":"$sent_http_x_trace_id"'
    '}';
    access_log logs/access.log json_log;
    error_log logs/error.log;

    # 3. 初始化 Lua 模块 (master 进程阶段)
    init_by_lua_block {
        -- 预加载模块
        require("core.metrics")
        require("core.circuit_breaker").init()
    }

    # 3.1 Worker 进程初始化 (lua-resty-prometheus 必须在此阶段初始化)
    init_worker_by_lua_block {
        local metrics = require("core.metrics")
        metrics.init()
    }

    # 4. 上游服务定义 (反向代理目标)
    upstream zerion {
        server api.zerion.io:443;
        keepalive 320; # 长连接保持
    }

    upstream coingecko {
        server api.coingecko.com:443;
        keepalive 320;
    }

    upstream alchemy {
        server eth-mainnet.g.alchemy.com:443;
        keepalive 320;
    }

    server {
        listen 8080;
        server_name localhost;

        # DNS resolver (使用 Docker 内部 DNS 和 Google DNS)
        resolver 127.0.0.11 8.8.8.8 valid=30s ipv6=off;
        resolver_timeout 5s;

        # 设置请求体缓冲和大小限制
        client_max_body_size 10m;
        client_body_buffer_size 128k;

        # 健康检查端点 (不需要走代理流程)
        location = /health {
            access_log off;
            default_type application/json;
            add_header X-OneKey-Speed-Check "yes";
            return 200 '{"resMsg": {"method": "", "code": 200, "message": true}}';
        }

        # Prometheus 指标端点 (标准格式，供 Prometheus 采集)
        location = /metrics {
            access_log off;
            # allow 127.0.0.1;      # 仅允许本地访问（Prometheus 采集器地址）
            # allow 10.0.0.0/8;     # 可选：允许内网监控系统
            # allow 172.16.0.0/12;  # Docker 内网
            # deny all;

            content_by_lua_block {
                local metrics = require("core.metrics")
                metrics.collect_metrics()
            }
        }

        # JSON 格式监控端点 (兼容旧接口，提供摘要信息)
        location = /metrics/json {
            access_log off;
            content_by_lua_block {
                local cjson = require("cjson")
                local metrics = require("core.metrics")
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode(metrics.get_report()))
            }
        }

        # Nginx 状态端点 (用于连接统计)
        location = /status {
            stub_status on;
            access_log off;
        }

        # 调试端点 - 显示 Header 过滤效果
        location = /debug/headers {
            content_by_lua_block {
                local cjson = require("cjson")
                local access_control = require("core.access_control")
                
                -- 获取原始 headers
                local original_headers = {}
                local headers = ngx.req.get_headers()
                for k, v in pairs(headers) do
                    original_headers[k] = v
                end
                
                -- 执行安全过滤
                access_control.sanitize_headers()
                
                -- 获取过滤后的 headers
                local filtered_headers = {}
                headers = ngx.req.get_headers()
                for k, v in pairs(headers) do
                    filtered_headers[k] = v
                end
                
                -- 不应转发给上游的 headers (会被 proxy_set_header 清空)
                local proxy_filtered = {
                    "Connection", "Keep-Alive", "Proxy-Authorization",
                    "Proxy-Authenticate", "TE", "Trailer", 
                    "Transfer-Encoding", "Upgrade", "Cookie", 
                    "Origin", "Referer"
                }
                
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    note = "此端点显示 Header 过滤效果",
                    original_headers = original_headers,
                    after_lua_filter = filtered_headers,
                    proxy_will_clear = proxy_filtered,
                    description = {
                        original_headers = "客户端发送的原始 Headers",
                        after_lua_filter = "经过 Lua sanitize_headers() 过滤后的 Headers",
                        proxy_will_clear = "proxy_pass 时会被 nginx 清空的 Headers"
                    }
                }))
            }
        }

        # 熔断器状态端点
        location = /circuit-breaker {
            content_by_lua_block {
                local cjson = require("cjson")
                local circuit_breaker = require("core.circuit_breaker")
                
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode(circuit_breaker.get_status()))
            }
        }

        # 熔断器管理端点 (重置/触发)
        location ~ ^/circuit-breaker/([^/]+)/(reset|trip)$ {
            content_by_lua_block {
                local cjson = require("cjson")
                local circuit_breaker = require("core.circuit_breaker")
                
                local provider = ngx.var[1]
                local action = ngx.var[2]
                
                ngx.header["Content-Type"] = "application/json"
                
                local result = false
                if action == "reset" then
                    result = circuit_breaker.reset(provider)
                elseif action == "trip" then
                    result = circuit_breaker.trip(provider)
                end
                
                if result then
                    ngx.say(cjson.encode({
                        success = true,
                        provider = provider,
                        action = action,
                        new_state = circuit_breaker.get_status(provider).state
                    }))
                else
                    ngx.status = 400
                    ngx.say(cjson.encode({
                        success = false,
                        error = "Invalid provider or action"
                    }))
                end
            }
        }

        # 根路径 - 返回服务信息
        location = / {
            content_by_lua_block {
                local cjson = require("cjson")
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    service = "OpenResty API Proxy",
                    version = "1.0.0",
                    endpoints = {
                        health = "/health",
                        metrics = "/metrics",
                        zerion = "/zerion/*",
                        coingecko = "/coingecko/*",
                        alchemy = "/alchemy/*"
                    }
                }))
            }
        }

        # API 代理端点 (需要完整的代理流程)
        location ~ ^/(zerion|coingecko|alchemy)/ {
            # 5. 访问阶段 (Access Phase)
            access_by_lua_block {
                local access_control = require("core.access_control")
                
                -- 5.1 生成或透传请求ID (用于链路追踪)
                access_control.handle_request_id()
                
                -- 5.2 安全过滤：移除不安全的Header
                access_control.sanitize_headers()
                
                -- 5.3 多维度限流 (IP, API Key, 路径)
                access_control.rate_limit()
                
                -- 5.4 熔断检查 (如果服务熔断，则直接拒绝)
                access_control.check_circuit_breaker()
            }

            # 7.1 超时配置 (稳定性设计)
            proxy_connect_timeout 2s;   # 连接后端超时
            proxy_send_timeout 10s;     # 发送请求超时
            proxy_read_timeout 15s;     # 读取响应超时
            
            # 7.2 重试策略 (非幂等方法谨慎重试，这里只重试连接错误)
            proxy_next_upstream error timeout http_502 http_503 http_504;
            proxy_next_upstream_timeout 20s; # 最大重试时间
            proxy_next_upstream_tries 3;     # 最多重试3次

            # 7.3 构建代理请求
            set $backend_host "";
            set $backend_uri "";
            set $add_api_key "";
            set $proxy_url "";
            set $fallback_provider "";

                rewrite_by_lua_block {
                local router = require("core.router")
                local target = router.route(ngx.var.uri)
                
                if target then
                    ngx.ctx.target = target
                    ngx.var.backend_host = target.upstream_host
                    ngx.var.backend_uri = target.backend_path
                    ngx.var.fallback_provider = target.provider
                    
                    -- 构建 proxy URL
                    ngx.var.proxy_url = "https://" .. target.upstream_host .. target.backend_path
                    
                    -- 设置自定义 Header (追踪ID)
                    ngx.req.set_header("X-OneKey-Request-Id", ngx.var.http_x_onekey_request_id)
                    
                    -- 注入认证信息
                    require("core.auth").inject(target.provider)
                else
                    ngx.status = 404
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error": "Route not found", "code": 404}')
                    ngx.exit(404)
                end
            }

            # 7.4 服务降级配置 - 拦截上游错误
            proxy_intercept_errors on;
            error_page 500 502 503 504 = @fallback;

            proxy_pass $proxy_url$is_args$args;
            
            # 7.4.1 必须设置的请求头
            proxy_set_header Host $backend_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # 7.4.2 清除不应转发的 Hop-by-hop Headers (RFC 2616)
            proxy_set_header Connection "";
            proxy_set_header Keep-Alive "";
            proxy_set_header Proxy-Authorization "";
            proxy_set_header Proxy-Authenticate "";
            proxy_set_header TE "";
            proxy_set_header Trailer "";
            proxy_set_header Transfer-Encoding "";
            proxy_set_header Upgrade "";
            
            # 7.4.3 清除可能泄露信息的 Headers
            proxy_set_header Cookie "";
            proxy_set_header Origin "";
            proxy_set_header Referer "";
            
            # 7.4.4 SSL 配置
            proxy_ssl_name $backend_host;
            proxy_ssl_server_name on;

            # 7.5 响应头过滤 - 添加自定义响应头
            header_filter_by_lua_block {
                -- 将请求ID添加到响应头，供客户端追踪
                local request_id = ngx.ctx.request_id
                if request_id then
                    ngx.header["X-OneKey-Request-Id"] = request_id
                end
                
                -- 添加 Provider 信息
                local target = ngx.ctx.target
                if target then
                    ngx.header["X-API-Provider"] = target.provider
                end
            }

            # 8. 日志阶段 (记录指标和日志)
            log_by_lua_block {
                local metrics = require("core.metrics")
                local logger = require("core.logger")
                local circuit_breaker = require("core.circuit_breaker")
                
                -- 8.1 收集监控指标 (延迟、状态码)
                metrics.collect()
                
                -- 8.2 异常日志处理 (大Body截断、敏感信息脱敏)
                logger.process()
                
                -- 8.3 记录熔断器状态
                local target = ngx.ctx.target
                if target then
                    local status = ngx.status
                    local latency_ms = (tonumber(ngx.var.request_time) or 0) * 1000
                    local provider = target.provider
                    
                    if status >= 200 and status < 400 then
                        circuit_breaker.record_success(provider, latency_ms)
                    else
                        -- 确定错误类型
                        local error_type = "unknown"
                        if status == 504 then
                            error_type = "timeout"
                        elseif status == 502 then
                            error_type = "connect_failed"
                        elseif status >= 500 then
                            error_type = "upstream_5xx"
                        elseif status >= 400 then
                            error_type = "client_error"
                        end
                        circuit_breaker.record_failure(provider, latency_ms, error_type)
                    end
                end
            }
        }

        # 服务降级处理 - 当上游服务异常时返回友好提示
        location @fallback {
            internal;
            
            content_by_lua_block {
                local cjson = require("cjson")
                local fallback = require("core.fallback")
                
                -- 获取 provider 信息
                local provider = ngx.var.fallback_provider or "unknown"
                local original_status = ngx.var.upstream_status or "503"
                
                -- 记录降级事件
                fallback.record_fallback(provider, original_status)
                
                -- 检测客户端语言偏好
                local accept_lang = ngx.req.get_headers()["Accept-Language"] or ""
                local lang = "zh"
                if string.match(accept_lang, "^en") then
                    lang = "en"
                end
                
                -- 构建降级响应消息
                local messages = {
                    zh = {
                        default = "服务繁忙，请稍后再试",
                        zerion = "Zerion 服务暂时不可用，请稍后再试",
                        coingecko = "CoinGecko 行情服务繁忙，请稍后再试",
                        alchemy = "Alchemy 区块链服务繁忙，请稍后再试"
                    },
                    en = {
                        default = "Service is busy, please try again later",
                        zerion = "Zerion service is temporarily unavailable, please try again later",
                        coingecko = "CoinGecko market service is busy, please try again later",
                        alchemy = "Alchemy blockchain service is busy, please try again later"
                    }
                }
                
                local msg_table = messages[lang] or messages.zh
                local message = msg_table[provider] or msg_table.default
                
                -- 确定错误类型
                local error_type = "service_unavailable"
                local status_num = tonumber(original_status) or 503
                if status_num == 504 then
                    error_type = "timeout"
                elseif status_num == 502 then
                    error_type = "connection_failed"
                end
                
                -- 构建响应
                local response = {
                    success = false,
                    code = 503,
                    message = message,
                    error = {
                        type = error_type,
                        provider = provider,
                        recoverable = true,
                        original_status = status_num
                    },
                    fallback = true,
                    retry_after = 30,
                    timestamp = ngx.time()
                }
                
                -- 设置响应头
                ngx.status = 503
                ngx.header["Content-Type"] = "application/json; charset=utf-8"
                ngx.header["Retry-After"] = "30"
                ngx.header["X-Fallback"] = "true"
                ngx.header["X-Fallback-Provider"] = provider
                ngx.header["X-Original-Status"] = tostring(original_status)
                
                -- 记录日志
                ngx.log(ngx.WARN, string.format(
                    "[Fallback] Provider: %s, Original Status: %s, Error Type: %s, Request: %s",
                    provider, original_status, error_type, ngx.var.uri
                ))
                
                ngx.say(cjson.encode(response))
            }
        }

        # 降级统计端点
        location = /fallback/stats {
            content_by_lua_block {
                local cjson = require("cjson")
                local fallback = require("core.fallback")
                
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    fallback_stats = fallback.get_stats(),
                    timestamp = ngx.time()
                }))
            }
        }

        # 测试服务降级的端点 - 模拟各种上游错误
        location = /test/fallback/502 {
            set $fallback_provider "test";
            proxy_pass http://127.0.0.1:19999;  # 不存在的端口，触发 502
            proxy_connect_timeout 1s;
            proxy_intercept_errors on;
            error_page 502 = @fallback;
        }

        location = /test/fallback/504 {
            set $fallback_provider "test";
            proxy_pass http://httpbin.org/delay/60;  # 超时
            proxy_connect_timeout 1s;
            proxy_read_timeout 1s;
            proxy_intercept_errors on;
            error_page 504 = @fallback;
        }

        location = /test/fallback/simulate {
            set $fallback_provider "";
            
            content_by_lua_block {
                local cjson = require("cjson")
                local fallback = require("core.fallback")
                
                -- 从 query 参数获取 provider
                local args = ngx.req.get_uri_args()
                local provider = args.provider or "test"
                local error_code = tonumber(args.code) or 503
                
                -- 记录降级事件
                fallback.record_fallback(provider, error_code)
                
                -- 检测语言偏好
                local accept_lang = ngx.req.get_headers()["Accept-Language"] or ""
                local lang = "zh"
                if string.match(accept_lang, "^en") then
                    lang = "en"
                end
                
                -- 降级消息
                local messages = {
                    zh = {
                        default = "服务繁忙，请稍后再试",
                        zerion = "Zerion 服务暂时不可用，请稍后再试",
                        coingecko = "CoinGecko 行情服务繁忙，请稍后再试",
                        alchemy = "Alchemy 区块链服务繁忙，请稍后再试",
                        test = "测试服务繁忙，请稍后再试"
                    },
                    en = {
                        default = "Service is busy, please try again later",
                        zerion = "Zerion service is temporarily unavailable",
                        coingecko = "CoinGecko market service is busy",
                        alchemy = "Alchemy blockchain service is busy",
                        test = "Test service is busy, please try again later"
                    }
                }
                
                local msg_table = messages[lang] or messages.zh
                local message = msg_table[provider] or msg_table.default
                
                local error_type = "service_unavailable"
                if error_code == 504 then
                    error_type = "timeout"
                elseif error_code == 502 then
                    error_type = "connection_failed"
                end
                
                local response = {
                    success = false,
                    code = 503,
                    message = message,
                    error = {
                        type = error_type,
                        provider = provider,
                        recoverable = true,
                        original_status = error_code
                    },
                    fallback = true,
                    retry_after = 30,
                    timestamp = ngx.time()
                }
                
                ngx.status = 503
                ngx.header["Content-Type"] = "application/json; charset=utf-8"
                ngx.header["Retry-After"] = "30"
                ngx.header["X-Fallback"] = "true"
                ngx.header["X-Fallback-Provider"] = provider
                ngx.header["X-Simulated-Error"] = tostring(error_code)
                
                ngx.say(cjson.encode(response))
            }
        }
    }

    # 9. 优雅降级端点 (当熔断时返回缓存或默认值)
    server {
        listen 8081;
        location /fallback {
            internal; # 仅内部调用
            content_by_lua_block {
                ngx.say('{"error": "Service temporarily unavailable, please try again later.", "code": 503}')
            }
        }
    }

}
